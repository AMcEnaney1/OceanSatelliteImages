"""
File: model_application_functions.py
Author: Aidan McEnaney
Date: 2023-08-11

Description: Module containing functions to apply models for use in obtaining various parameters.

Contents:
    - model_routine_space_eff: Function to perform core of model execution, while deleting files.
    - model_routine: Function to perform core of model execution, does not delete files.
    - convert_eff: Function to convert output from POLYMER (NetCDF) to NumPy files.
    - calculate_and_save_result: Function to perform linear model on npy file.


Notes:
    - This code is distributed under the MIT License. See LICENSE.txt for more details.
"""

# Standard library imports
import os

# Third-party library imports
import numpy as np

# Local module imports
import utils.misc_functions as mf
import local_sentinelsat.sentinelsat_manage_functions as smf
import utils.polymer_functions as pf
import utils.io_functions as io
import utils.file_conversion_functions as fcf
import models.model_functions as mmf
from config import *

def model_routine_space_eff(bbox, date_tuples, project_name, model, poly_dir, request_function, npy_save_to=None):
    """
    This function handles downloading, unzipping and moving files,
    before then running POLYMER on them, calling the specified model,
    then deleting the raw nc files and data to save on storage.

    Args:
        bbox (tuple): Bounding box coordinates.
        date_tuples (list of tuples): List of date tuples for the time periods.
        project_name (str): Name of the project.
        model (str): Name of the model to be called.
        poly_dir (str): Path to the directory where POLYMER will operate.
        request_function (function): Function to call for downloading files.
        npy_save_to (str): Path to save npy files. Default is None.
        polymer_root_name (str): Root name of POLYMER executable. Default is 'polymer-v4.16.1'.

    Returns:
        None
    """

    io.create_batch_folders(poly_dir)

    if (npy_save_to == None):  # Default folder for npy files, this is so POLYMER doesnt get upset
        npy_save_to = project_name + '_' + 'npyFiles'

    for i in range(len(date_tuples)):

        date_tuple = [(str(date_tuples[i][0]), str(date_tuples[i][1]))]

        smf.sentinelsat_routine(bbox, date_tuple, poly_dir, request_function)

        filevals = mf.get_surface_level_folders(poly_dir)  # Gets a list of the downloaded folders

        for i in range(len(filevals)):
            filevals[i] = os.path.join(poly_dir, filevals[i])

        folder = mf.most_recent_folder(filevals)

        pf.call_polymer(folder)

        convert_eff(poly_dir, npy_save_to, model)

        io.delete_folder_with_contents(folder) # Deletes sentinel folder
        file = mf.find_files_with_strings(poly_dir, folder) # Finds polymer output file
        io.del_file(file[0]) # Deletes found file
        io.delete_folder_with_contents(os.path.join(poly_dir, npy_save_to)) # Deletes the excess files generated by model

def model_routine(bbox, date_tuples, project_name, path, model, poly_dir, request_function,
                  del_sat_folder=False, del_poly_file=False, del_excess=False,
                  npy_save_to=None):
    """
    Similar to 'model_routine_space_eff()', however, by default none of files are deleted.
    This would probably take up hundreds of gigabytes, even with a relatively small number of data points.
    As such this function is really only useful for testing purposes or to view very small batches of data.

    Args:
        bbox (tuple): Bounding box coordinates.
        date_tuples (list of tuples): List of date tuples for the time periods.
        project_name (str): Name of the project.
        model (str): Name of the model to be called.
        poly_dir (str): Path to the directory where POLYMER will operate.
        request_function (function): Function to call for downloading files.
        npy_save_to (str): Path to save npy files. Default is None.
        polymer_root_name (str): Root name of POLYMER executable. Default is 'polymer-v4.16.1'.

    Returns:
        None
    """

    if (npy_save_to == None):  # Default folder for npy files, this is so POLYMER doesnt get upset
        npy_save_to = project_name + '_' + 'npyFiles'

    for i in range(len(date_tuples)):

        date_tuple = [(str(date_tuples[i][0]), str(date_tuples[i][1]))]

        poly_dir2 = mf.remove_overlap(os.getcwd(), poly_dir)

        smf.sentinelsat_routine(bbox, date_tuple, poly_dir2, request_function)

        filevals = mf.get_surface_level_folders(poly_dir)  # Gets a list of the downloaded folders

        for i in range(len(filevals)):
            filevals[i] = os.path.join(poly_dir, filevals[i])

        folder = mf.most_recent_folder(filevals)

        pf.call_polymer(folder)

        convert_eff(poly_dir, npy_save_to, model)

        if (del_sat_folder):
            io.delete_folder_with_contents(folder) # Deletes sentinel folder

        if (del_poly_file):
            file = mf.find_files_with_strings(poly_dir, folder) # Finds polymer output file
            io.del_file(file[0]) # Deletes found file

        if (del_excess):
            io.delete_folder_with_contents(os.path.join(poly_dir, npy_save_to)) # Deletes the excess files generated by model

def convert_eff(tmp_, npy_save_to, model_func):
    """
    Converts output from POLYMER (NetCDF) to NumPy files, calls a specified model,
    and performs necessary directory changes.

    Args:
        tmp_ (str): Temporary directory where POLYMER output is stored.
        npy_save_to (str): Path to save NumPy files.
        model_func (function): Specified model function to be called.
        polymer_root_name (str): Root name of POLYMER directory.

    Returns:
        None
    """

    os.chdir(os.path.join(os.getcwd(), polymer_path)) # Change directory to that of polymer

    tmp_ = mf.remove_overlap(os.getcwd(), tmp_)

    io.move_files_by_type(os.getcwd(), tmp_, '.nc') # Moves the outputs from POLYMER

    filevals = mf.get_surface_level_folders(tmp_) # Gets a list of the downloaded folders

    paths = mf.find_files_with_strings(tmp_, filevals) # Get nc files output by POLYMER to convert to npy

    for path in paths: # Creates npy files for all the parts of each nc file
        fcf.convert_nc_to_npy(path, save_to=npy_save_to)

    path = mf.most_recent_folder(paths)

    fcf.convert_nc_to_npy(path, save_to=npy_save_to)

    name = mf.remove_overlap(tmp_, paths[0])
    name = name.rsplit('.', 1)[0]

    model_func(os.getcwd(), tmp_, npy_save_to, name) # Calls the specified model

    os.chdir(os.path.dirname(os.getcwd())) # Move back one directory, like with cd ..


def calculate_and_save_result(npy_files, float_list, name, saveLoc):
    """
    Calculate a weighted sum using data from .npy files and save the result to a new .npy file.

    Args:
        npy_files (list): List of paths to .npy files containing data.
        float_list (list): List of floating-point weights for each .npy file.
        name (str): Name of the output .npy file (without extension).
        saveLoc (str): Directory where the output .npy file will be saved.

    Returns:
        None
    """

    if len(float_list) != len(npy_files) + 1:
        print(f"npy files: '{npy_files}'")
        print(f"float list: '{float_list}'")
        raise ValueError("The length of float_list should be one more than the number of npy_files.")

    # Read the data from each .npy file and store it in a list
    npy_data = [np.load(file_path) for file_path in npy_files]

    # Perform the calculations
    result = float_list[0]
    for i in range(len(npy_data)):
        result += float_list[i+1] * npy_data[i]

    name = name + '.npy'
    savePath = os.path.join(saveLoc, name)

    # Save the result to a new .npy file
    np.save(savePath, result)